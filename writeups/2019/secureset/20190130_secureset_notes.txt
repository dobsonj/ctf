
 Linux: 192.168.1.2
 Steganography: 192.168.1.6
 Appsec: 192.168.1.4
 Crypto: 192.168.1.5

 On all four stacks, start off by logging in with:
 ssh lev1@192.168.*.*
 Password: password

 Enter passwords (i.e. flags) at:
 http://192.168.1.3/ 


**crypto**

nulladdr@unknown:~$ ssh lev1@192.168.1.5

lev1@SecureSet-CTF-Crypto:~$ cd /var/challenge/level1
lev1@SecureSet-CTF-Crypto:/var/challenge/level1$ ls
crypto1.txt  HINT1
lev1@SecureSet-CTF-Crypto:/var/challenge/level1$ cat HINT1 
The first level is easy!

The password to level1 (in crypto1.txt) has been masked using base64 encoding.
lev1@SecureSet-CTF-Crypto:/var/challenge/level1$ cat crypto1.txt 
SFlJVEVTV1VTV1lMVkxNUkZIT0w=
lev1@SecureSet-CTF-Crypto:/var/challenge/level1$ cat crypto1.txt | base64 -D
base64: invalid option -- 'D'
Try 'base64 --help' for more information.
lev1@SecureSet-CTF-Crypto:/var/challenge/level1$ cat crypto1.txt | base64 -d
HYITESWUSWYLVLMRFHOL


nulladdr@unknown:~$ ssh lev2@192.168.1.5

lev2@SecureSet-CTF-Crypto:~$ ls
lev2@SecureSet-CTF-Crypto:~$ cd /var/challenge/level2
lev2@SecureSet-CTF-Crypto:/var/challenge/level2$ ls
crypto2  HINT2
lev2@SecureSet-CTF-Crypto:/var/challenge/level2$ cat HINT2 
The binary executable 'crypto2' will encrypt any input using a simple rotation cipher.

It also gives you a BIG hint about how to find the password to level3!
lev2@SecureSet-CTF-Crypto:/var/challenge/level2$ ./crypto2 
Usage: ./crypto2 <input>
lev2@SecureSet-CTF-Crypto:/var/challenge/level2$ ./crypto2 foo
Illegal characters.  Upper-case only, please.
lev2@SecureSet-CTF-Crypto:/var/challenge/level2$ ./crypto2 FOO
Incorrect.
Your input, rotated by 13:
	SBB
Try matching LWJUNXLZDLBADFURMGJV

https://www.mobilefish.com/services/rot13/rot13.php

lev2@SecureSet-CTF-Crypto:/var/challenge/level2$ ./crypto2 YJWHAKYMQYONQSHEZTWI
Correct!
The next flag is:
YJWHAKYMQYONQSHEZTWI


nulladdr@unknown:~$ ssh lev3@192.168.1.5


ureSet-CTF-Crypto:~$ cd /var/challenge/level3
lev3@SecureSet-CTF-Crypto:/var/challenge/level3$ ls
crypto3  HINT3
lev3@SecureSet-CTF-Crypto:/var/challenge/level3$ cat HINT3 
This challenge is very similar to the previous one, except this time you don't know how much the input is being rotated!
lev3@SecureSet-CTF-Crypto:/var/challenge/level3$ ./crypto3 FOO
Incorrect.
Your input, rotated by <unknown amount>:
	WFF
Try matching UBXQVWDHLTPNFVDCEKSV

ureSet-CTF-Crypto:/var/challenge/level3$ ./crypto3 ABC
Incorrect.
Your input, rotated by <unknown amount>:
	RST
Try matching UBXQVWDHLTPNFVDCEKSV

rot-17, so rot-9 to reverse.

https://www.mobilefish.com/services/rot13/rot13.php

lev3@SecureSet-CTF-Crypto:/var/challenge/level3$ ./crypto3 DKGZEFMQUCYWOEMLNTBE
Correct!
The next flag is:
DKGZEFMQUCYWOEMLNTBE


nulladdr@unknown:~$ ssh lev4@192.168.1.5

lev4@SecureSet-CTF-Crypto:~$ cd /var/challenge/level4
lev4@SecureSet-CTF-Crypto:/var/challenge/level4$ ls
crypto4  HINT4
lev4@SecureSet-CTF-Crypto:/var/challenge/level4$ cat HINT4 
Rotation ciphers are simple examples of a more general cipher, called a 'substitution cipher.'

Substitution ciphers are a simple replacement algorithm.  Each letter in the alphabet is simply replaced with a different one.  Again, the executable will encrypt any input you give it, and it gives you a BIG hint to find the password to level 5!

lev4@SecureSet-CTF-Crypto:/var/challenge/level4$ ./crypto4 A
Incorrect.
Your input, run through an internal substitution cipher:
	G
Try matching DWTZGQDOGPNYVWNEDGAZ

lev4@SecureSet-CTF-Crypto:/var/challenge/level4$ ./crypto4 A | tail -2 | head -1 | awk '{print $1}'
G
lev4@SecureSet-CTF-Crypto:/var/challenge/level4$ echo -n A=; ./crypto4 A | tail -2 | head -1 | awk '{print $1}'
A=G

lev4@SecureSet-CTF-Crypto:/var/challenge/level4$ for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y Z; do echo -n "$i="; ./crypto4 $i | tail -2 | head -1 | awk '{print $1}'; done
A=G
B=I
C=V
D=S
E=R
F=P
G=J
H=N
I=Y
J=K
K=Q
L=E
M=D
N=Z
O=W
P=B
Q=T
R=U
S=F
T=M
U=A
V=X
W=H
X=L
Y=C
Z=O

lev4@SecureSet-CTF-Crypto:/var/challenge/level4$ ./crypto4 MOQNAKMZAFHICOHLMAUN
Correct!
The next flag is:
MOQNAKMZAFHICOHLMAUN


nulladdr@unknown:~$ ssh lev5@192.168.1.5

lev5@SecureSet-CTF-Crypto:~$ cd /var/challenge/level5
lev5@SecureSet-CTF-Crypto:/var/challenge/level5$ ls
crypto5.txt  HINT5
lev5@SecureSet-CTF-Crypto:/var/challenge/level5$ cat HINT5 
RSA (Rivest, Shamir, Adleman) is a simple, but effective, algorithm for encryption using public key cryptography.

The basic operation is actually just exponentiation!  (modular exponentation, that is...)

Example:
p and q are prime numbers
n is equal to the product p * q
phi is equal to the product (p-1) * (q-1)
e is called the "public exponent"
d is called the "private exponent"
The relationship between e and d:
    (e * d) % phi = 1

To encrypt a message m into a ciphertext c:
    c = (m**e) % n

To decrypt a message c back to a message m:
    m = (c**d) % n

Note: The double asterisk (**) refers to exponentiation.  Python does modular exponentiation efficiently with the pow() function:
    pow(a, b, n)

Your challenge:
    We have used a weak form of RSA (small numbers) to generate ciphertexts (since ciphertext is really just an integer, we give it to you in hex).  We have given you the public key used to encrypt.  Since the numbers are so small, you should be able to guess the private key (for decryption) and decrypt the ciphertext to get the plaintext (which will be an integer also).

Better explanation of steps:
    Factorize n into p and q (this is the hard part in full-strength RSA!)
    Once you know p and q, compute phi (defined above)
    Once you know phi, compute d (there are elegant ways to do this, but you should be able to guess it using brute force)
    Use the decryption method (above) to decrypt the ciphertexts

The password for level 6 is the plaintext, (an integer, but converted into hex).  It should be 7 characters long and all caps.

lev5@SecureSet-CTF-Crypto:/var/challenge/level5$ cat crypto5.txt 
Modulus (n): 600617
Public exponent (e): 65537
Private exponent (d): ????
Ciphertext1 (in hex): 0x76E38
Ciphertext2 (in hex): 0x852F
Plaintext (in hex): ???????

nulladdr@unknown:~$ python3
Python 3.5.3 (default, Sep 27 2018, 17:25:39) 
[GCC 6.3.0 20170516] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> n=600617
>>> e=65537

    Factorize n into p and q (this is the hard part in full-strength RSA!)
    n is equal to the product p * q

https://stackoverflow.com/questions/23287/algorithm-to-find-largest-prime-factor-of-a-number/412942#412942

>>> def prime_factors(n):
...     """Returns all the prime factors of a positive integer"""
...     factors = []
...     d = 2
...     while n > 1:
...         while n % d == 0:
...             factors.append(d)
...             n /= d
...         d = d + 1
...         if d*d > n:
...             if n > 1: factors.append(n)
...             break
...     return factors
... 
>>> pfs = prime_factors(n)
>>> print(pfs)
[641, 937.0]
>>> p=641
>>> q=937

    Once you know p and q, compute phi (defined above)
    phi is equal to the product (p-1) * (q-1)

>>> phi=(p-1)*(q-1)
>>> print(phi)
599040

    Once you know phi, compute d (there are elegant ways to do this, but you should be able to guess it using brute force)
    d is called the "private exponent"
    The relationship between e and d:
        (e * d) % phi = 1

>>> print(phi)
599040
>>> print(phi+1)
599041
>>> for i in range(1, 1000000):
...     if ((e*i)%phi) == 1:
...             d=i
...             print(d)
... 
489473

    Use the decryption method (above) to decrypt the ciphertexts
    To decrypt a message c back to a message m:
        m = (c**d) % n

>>> c1 = 0x76E38
>>> c2 = 0x852F
>>> print(hex(pow(c1, d, n)))
0xbad
>>> print(hex(pow(c2, d, n)))
0xfade

  It should be 7 characters long and all caps.

BADFADE


nulladdr@unknown:~$ ssh lev6@192.168.1.5

lev6@SecureSet-CTF-Crypto:~$ cd /var/challenge/level6/
lev6@SecureSet-CTF-Crypto:/var/challenge/level6$ ls
HINT6
lev6@SecureSet-CTF-Crypto:/var/challenge/level6$ cat HINT6 
Cryptographic hashes are used to produce 'fingerprints' of (potentially) large amounts of data.
The idea is that a hash alone should not be enough to reconstruct the original data.
Nevertheless, when a short password is hashed, the password can be recovered by simply guessing and checking.
Some people even have big online databases of passwords and hashes...

The following is the SHA1 hash of the password to level 7 
4eadea95c4eb4153651e82193ef61df26324940a

https://crackstation.net/

4eadea95c4eb4153651e82193ef61df26324940a	sha1	MORPHEUS

